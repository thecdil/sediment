---
layout: default
title: "The Colorado River Journey"
river_path: "M190,-10 Q105,0 100,0 T65,15 50,23 Q45,25 30,35 Q20,45 19,65 Q42,75 50,85 Q53,95 67,105 Q80,115 93,125 Q92,135 80,145 Q74,155 60,165 Q57,175 59,185 Q52,195 50,205 Q47,215 49,225 Q42,235 40,245 Q47,255 59,265 Q72,275 70,285 Q67,295 59,305 Q52,310 50,320 Q47,330 39,340 Q32,350 30,360 Q35,370 45,380 Q55,390 65,400 Q75,410 85,420 Q95,430 98,440 Q92,450 85,460 Q78,470 75,480 Q72,490 78,500 Q84,510 90,520 Q96,530 98,540 Q95,550 88,560 Q81,570 75,580 Q69,590 72,600 Q75,610 82,620 Q89,630 95,640 Q98,650 95,660 Q92,670 85,680 Q78,690 72,700 Q66,710 70,720 Q74,730 82,740 Q90,750 96,760 Q98,770 94,780 Q90,790 83,800 Q76,810 70,820 Q64,830 68,840 Q72,850 80,860 Q88,870 94,880 Q98,890 95,900"
---

<div class="river-container">
  
  <!-- Navigation -->
  <nav class="river-nav position-fixed top-0 start-0 p-3 w-25">
      {% include side-nav-banner.html %}
    
  </nav>

  <!-- Introductory Content Box -->
  <div class="intro-content-box">
    
{% capture intro_content %}{% include intro.md %}{% endcapture %}
{{ intro_content | markdownify }}

    <div class="intro-buttons">
      <a href="{{ '/about.html' | relative_url }}" class="btn btn-primary btn-sm me-2">About</a>
      <a href="{{ '/resources.html' | relative_url }}" class="btn btn-outline-primary btn-sm">Resources</a>
    </div>
  </div>

  <!-- Canvas River -->
  <canvas id="riverCanvas" class="river-canvas"></canvas>

  <!-- Tributary Points
  <div class="tributary-scroll-container">
    {% assign sorted_tributaries = site.tributaries | sort: "scroll_position" %}
    {% for tributary in sorted_tributaries %}
      <div class="tributary-step" 
           id="{{ tributary.title | downcase }}"
           data-step="{{ forloop.index0 }}"
           data-position="{{ tributary.position }}" 
           data-side="{{ tributary.side }}"
           style="top: {{ tributary.scroll_position }}px; height: 400px;">
        
        {% if tributary.side == 'left' %}
          <div class="tributary-content tributary-left">
            <div class="tributary-branch-left"></div>
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
          </div>
        {% else %}
          <div class="tributary-content tributary-right">
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
            <div class="tributary-branch-right"></div>
          </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>  -->

  <!-- Poem Narrative -->
  {% include river-poem.html %}
</div>

<style>
.river-container {
  position: relative;
  width: 100%;
  min-height: 6000px;
  background: linear-gradient(180deg, #F5DEB3 0%, #DEB887 30%, #D2691E 70%, #8B4513 100%);
  overflow-x: hidden;
}

.river-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.river-nav {
  z-index: 1000;
}

/* Circular map button styling - match sediment header */
.river-nav .sediment-map-toggle {
  width: 60px !important;
  height: 60px !important;
  border-radius: 50% !important;
  box-shadow: 0 4px 12px rgba(139, 69, 19, 0.3) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0 !important;
  background-color: #F8F6F0 !important;
  border: 2px solid #D2691E !important;
}

.river-nav .sediment-map-toggle .map-icon {
  width: 28px !important;
  height: 28px !important;
  color: #8B4513 !important;
}

.river-nav .sediment-map-toggle:hover {
  background-color: #FFF !important;
  box-shadow: 0 6px 16px rgba(139, 69, 19, 0.4) !important;
}

.intro-content-box {
  position: absolute;
  top: 240px;
  right: 30px;
  width: 650px;
  background: white;
  padding: 25px;
  
  z-index: 200;
  animation: fadeInUp 1s ease-out;
}

.intro-content-box h2 {
  color: #8B4513;
  font-size: 24px;
  margin-bottom: 15px;
  font-weight: 600;
}

.intro-content-box p {
  color: #5D4037;
  font-size: 16px;
  line-height: 1.6;
  margin-bottom: 15px;
}

.intro-buttons {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

.intro-buttons .btn {
  font-size: 13px;
  padding: 8px 16px;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
.poem-content-box{
background: rgb(255 255 255 / 65%);
    padding: 14px;}

.tributary-scroll-container {
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 100;
}

.tributary-step {
  position: absolute;
  width: 100%;
  z-index: 100;
}

.tributary-content {
  display: flex;
  align-items: center;
  opacity: 0;
  transform: translateY(50px);
  transition: all 0.8s ease;
}

.tributary-content.is-active {
  opacity: 1;
  transform: translateY(0);
}

.tributary-left {
  justify-content: flex-start;
  padding-left: 20px;
}

.tributary-right {
  justify-content: flex-end;
  padding-right: 20px;
}

.tributary-branch-left,
.tributary-branch-right {
  width: 100px;
  height: 3px;
  background: linear-gradient(90deg, #D2691E, transparent);
  position: relative;
}

.tributary-branch-right {
  background: linear-gradient(-90deg, #D2691E, transparent);
}

.content-box {
  background: rgba(245, 222, 179, 0.95);
  padding: 20px;
  border-radius: 12px;
  max-width: 300px;
  box-shadow: 0 8px 32px rgba(139, 69, 19, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(210, 105, 30, 0.3);
}

.content-box h3 {
  margin-bottom: 10px;
  color: #8B4513;
  font-size: 18px;
}

.content-box p {
  margin-bottom: 15px;
  font-size: 15px;
  line-height: 1.4;
  color: #5D4037;
}

.btn-outline-primary {
  border-color: #D2691E;
  color: #D2691E;
}

.btn-outline-primary:hover {
  background-color: #D2691E;
  border-color: #D2691E;
  color: white;
}

.btn-primary {
  background-color: #D2691E;
  border-color: #D2691E;
  color: white;
}

.btn-primary:hover {
  background-color: #B8860B;
  border-color: #B8860B;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .river-container {
    min-height: 8600px; /* Increased height for mobile to accommodate spread-out poem sections */
  }

  .intro-content-box {
    position: relative;
    top: 40px;
    right: auto;
    width: calc(100% - 30px);
    margin: 20px;
    background: white;
  border-radius: 15px;
  box-shadow: 0 12px 40px rgba(139, 69, 19, 0.4);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(210, 105, 30, 0.3);
  }

  .tributary-left,
  .tributary-right {
    padding: 10px;
    justify-content: center;
  }

  .tributary-branch-left,
  .tributary-branch-right {
    display: none;
  }

  .content-box {
    max-width: 280px;
  }
}

</style>

<!-- Load Scrollama -->
<script src="{{ '/assets/lib/scrollama.js' | relative_url }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('riverCanvas');
  const ctx = canvas.getContext('2d');
  
  // Desert color palette
  const colors = {
    path: '#8B4513',
    particles: ['#CD853F', '#D2691E', '#F4A460', '#DEB887', '#BC8F8F', '#A0522D'],
    glow: '#F4A460'
  };
  
  // Set up canvas responsively
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = 5500;
  }
  
  resizeCanvas();
  
  // Parse the SVG path to canvas coordinates
  const pathString = "{{ page.river_path }}";
  
  function parsePathToPoints(pathStr) {
    const points = [];
    const commands = pathStr.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);
    let currentX = 0, currentY = 0;
    
    // Original SVG bounds
    const originalBounds = { minX: 0, maxX: 200, minY: -10, maxY: 400 };
    
    commands.forEach(command => {
      const type = command[0];
      const coords = command.slice(1).trim().split(/[\s,]+/).map(Number);
      
      if (type === 'M') {
        currentX = coords[0];
        currentY = coords[1];
        const scaledX = (currentX / originalBounds.maxX) * canvas.width;
        const scaledY = ((currentY - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
        points.push({x: scaledX, y: scaledY});
      } else if (type === 'Q') {
        const steps = 25;
        const startX = currentX, startY = currentY;
        const cpX = coords[0], cpY = coords[1];
        const endX = coords[2], endY = coords[3];
        
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = (1-t)*(1-t)*startX + 2*(1-t)*t*cpX + t*t*endX;
          const y = (1-t)*(1-t)*startY + 2*(1-t)*t*cpY + t*t*endY;
          const scaledX = (x / originalBounds.maxX) * canvas.width;
          const scaledY = ((y - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
          points.push({x: scaledX, y: scaledY});
        }
        
        currentX = endX;
        currentY = endY;
      } else if (type === 'T') {
        const steps = 15;
        const endX = coords[0], endY = coords[1];
        
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = currentX + t * (endX - currentX);
          const y = currentY + t * (endY - currentY);
          const scaledX = (x / originalBounds.maxX) * canvas.width;
          const scaledY = ((y - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
          points.push({x: scaledX, y: scaledY});
        }
        
        currentX = endX;
        currentY = endY;
      }
    });
    
    return points;
  }
  
  let pathPoints = parsePathToPoints(pathString);
  
  // Particle class with settling behavior (using percentages)
  class Particle {
    constructor(x, y, isRiverBed = false) {
      // Store positions as percentages of canvas dimensions
      this.x = x / canvas.width; // Convert to percentage
      this.y = y / canvas.height; // Convert to percentage
      this.targetX = this.x;
      this.targetY = this.y;
      this.vx = isRiverBed ? 0 : (Math.random() - 0.5) * 0.0012; // Percentage-based velocity
      this.vy = isRiverBed ? 0 : Math.random() * 0.0008 + 0.0005; // Percentage-based velocity
      this.life = 1;
      this.decay = isRiverBed ? 0 : Math.random() * 0.008 + 0.002;
      this.size = (Math.random() * 1.2 + 0.5) / Math.min(canvas.width, canvas.height) * 1000; // Responsive size
      this.color = colors.particles[Math.floor(Math.random() * colors.particles.length)];
      this.isRiverBed = isRiverBed;
      this.settled = isRiverBed;
      this.distanceToRiver = Infinity;
    }
    
    update(drawnPoints) {
      if (!this.settled) {
        // Move particle
        this.x += this.vx;
        this.y += this.vy;
        
        // Find distance to nearest drawn river point (in percentage space)
        this.distanceToRiver = Infinity;
        let nearestPoint = null;
        
        for (let point of drawnPoints) {
          const pointX = point.x / canvas.width;
          const pointY = point.y / canvas.height;
          const dist = Math.sqrt(Math.pow(this.x - pointX, 2) + Math.pow(this.y - pointY, 2));
          if (dist < this.distanceToRiver) {
            this.distanceToRiver = dist;
            nearestPoint = {x: pointX, y: pointY};
          }
        }
        
        // Settle if close to river (doubled distance for larger river)
        if (this.distanceToRiver < 0.036 && nearestPoint) { // 0.036 * 2 for doubled size
          this.settled = true;
          this.targetX = nearestPoint.x + (Math.random() - 0.5) * 0.048; // 0.048 * 2 for doubled width
          this.targetY = nearestPoint.y + (Math.random() - 0.5) * 0.024; // 0.024 * 2 for doubled width
          this.vx *= 0.1;
          this.vy *= 0.1;
          this.decay = 0; // Stop decaying when settled
          this.life = 1;
        } else {
          // Decay if too far from river for too long
          this.life -= this.decay;
        }
        
        // Gravity toward river if detected (doubled range)
        if (this.distanceToRiver < 0.07 && nearestPoint) { // 0.07 * 2 for doubled attraction range
          const attraction = 0.05;
          const dx = nearestPoint.x - this.x;
          const dy = nearestPoint.y - this.y;
          this.vx += dx * attraction / this.distanceToRiver;
          this.vy += dy * attraction / this.distanceToRiver;
        }
      } else {
        // Gentle settling motion
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        this.x += dx * 0.05;
        this.y += dy * 0.05;
        
        // Gentle sway for settled particles
        const time = Date.now() * 0.001;
        this.x += Math.sin(time + this.targetX * 100) * 0.0001;
        this.y += Math.cos(time + this.targetY * 100) * 0.00005;
      }
    }
    
    draw() {
      if (this.life <= 0) return;
      
      ctx.save();
      ctx.globalAlpha = Math.min(this.life, this.settled ? 0.9 : 0.7);
      
      // Convert percentage coordinates back to pixels for drawing
      const pixelX = this.x * canvas.width;
      const pixelY = this.y * canvas.height;
      const pixelSize = this.size * Math.min(canvas.width, canvas.height) / 1000;
      
      // No glow - solid particles
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pixelX, pixelY, pixelSize, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  let particles = [];
  let riverBedParticles = [];
  let drawnPoints = [];
  let currentPointIndex = 0;
  let scrollProgress = 0;
  let timeProgress = 0;
  let lastScrollY = 0;
  let startTime = Date.now();
  
  // Create initial river bed particles at each path point
  function createRiverBed() {
    for (let i = 0; i < pathPoints.length; i += 1) { // More frequent points
      const point = pathPoints[i];
      // Create more particles around each point for wider river (doubled)
      for (let w = 0; w < 400; w++) { // Quadruple the particles for doubled river
        const offsetX = (Math.random() - 0.5) * 0.048; // 0.048 * 2 for doubled width (percentage)
        const offsetY = (Math.random() - 0.5) * 0.024; // 0.024 * 2 for doubled width (percentage)
        riverBedParticles.push(new Particle(
          point.x + offsetX * canvas.width, 
          point.y + offsetY * canvas.height, 
          true
        ));
      }
    }
  }
  
  function getScrollProgress() {
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight - windowHeight;
    const scrolled = window.pageYOffset;
    return Math.min(scrolled / documentHeight, 1);
  }
  
  function getTimeProgress() {
    const elapsed = (Date.now() - startTime) / 1000;
    return Math.min(elapsed / 25, 1); // total seconds of animation
  }
  
  function spawnParticles(x, y, count = 3) { // More particles
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = (Math.random() * 0.07 + 0.03) * canvas.width; // Doubled spawn area (percentage-based)
      const px = x + Math.cos(angle) * distance;
      const py = y + Math.sin(angle) * distance;
      particles.push(new Particle(px, py));
    }
  }
  
  function animate() {
    // Clear canvas with slight trail
    ctx.fillStyle = 'rgba(248, 245, 240, 0.08)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update progress
    scrollProgress = getScrollProgress();
    timeProgress = getTimeProgress();
    const revealProgress = Math.max(scrollProgress, timeProgress);
    
    // Draw path progressively
    const targetIndex = Math.floor(revealProgress * pathPoints.length);
    
    if (currentPointIndex < targetIndex && currentPointIndex < pathPoints.length) {
      const point = pathPoints[currentPointIndex];
      drawnPoints.push(point);
      
      // Spawn more settling particles at river edge
      if (Math.random() < 0.8) { // Higher spawn rate
        spawnParticles(point.x, point.y, 2); // More particles per spawn
      }
      
      currentPointIndex++;
    }
    
    // Update and draw river bed particles (only revealed ones)
    const revealedBedCount = Math.floor(revealProgress * riverBedParticles.length);
    for (let i = 0; i < revealedBedCount; i++) {
      const particle = riverBedParticles[i];
      particle.update(drawnPoints);
      particle.draw();
    }
    
    // Update and draw flowing particles
    particles = particles.filter(particle => {
      particle.update(drawnPoints);
      particle.draw();
      return particle.life > 0 || particle.settled;
    });
    
    // Occasionally spawn new particles along revealed river
    if (drawnPoints.length > 10 && Math.random() < 0.25) { // Higher spawn rate
      const randomPoint = drawnPoints[Math.floor(Math.random() * drawnPoints.length)];
      spawnParticles(randomPoint.x, randomPoint.y, 2); // More particles
    }
    
    requestAnimationFrame(animate);
  }
  
  // Initialize function to set up or reset the river
  function initializeRiver() {
    // Reset all state
    drawnPoints = [];
    currentPointIndex = 0;
    scrollProgress = 0;
    timeProgress = 0;
    lastScrollY = 0;
    startTime = Date.now();
    particles = [];
    riverBedParticles = [];

    // Recreate river bed
    createRiverBed();
  }

  // Initialize on first load
  initializeRiver();

  // Start animation
  animate();

  // Handle page show (fires on back button navigation)
  window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
      // Page was loaded from bfcache (back/forward button)
      // Reset the river state
      initializeRiver();
    }
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    resizeCanvas();
    pathPoints = parsePathToPoints(pathString);
    drawnPoints = [];
    currentPointIndex = 0;
    // Clear and recreate river bed for new dimensions
    riverBedParticles = [];
    particles = []; // Clear flowing particles too
    createRiverBed();
  });
  
  // Handle scroll for particle generation
  window.addEventListener('scroll', () => {
    const currentScrollY = window.pageYOffset;
    if (currentScrollY > lastScrollY && scrollProgress > 0.02) {
      // Generate particles when scrolling down
      if (drawnPoints.length > 5 && Math.random() < 0.7) { // Higher spawn rate
        const randomPoint = drawnPoints[Math.floor(Math.random() * drawnPoints.length * 0.8)];
        spawnParticles(randomPoint.x, randomPoint.y, 2); // More particles
      }
    }
    lastScrollY = currentScrollY;
  });
  
  // Initialize Scrollama for tributary activation
  if (typeof scrollama !== 'undefined') {
    const scroller = scrollama();
    scroller
      .setup({
        step: '.tributary-step',
        offset: 0.6,
        debug: false
      })
      .onStepEnter((response) => {
        const content = response.element.querySelector('.tributary-content');
        if (content) {
          content.classList.add('is-active');
        }
      });
    
    window.addEventListener('resize', scroller.resize);
  }
});
</script>
