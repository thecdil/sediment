---
layout: default
title: "The Colorado River Journey"
river_path: "M190,-10 Q105,0 100,0 T65,15 50,23 Q45,25 30,35 Q20,45 19,65 Q22,75 20,85 Q17,95 19,105 Q22,115 20,125 Q17,135 19,145 Q22,155 20,165 Q17,175 19,185 Q22,195 20,205 Q17,215 19,225 Q22,235 20,245 Q17,255 19,265 Q22,275 20,285 Q17,295 19,305 Q22,310 20,320 Q17,330 19,340 Q22,350 20,360 Q17,385 19,400"
features:
  - type: "text-block"
    id: "river-source"
    title: "River Source"
    content: "The Colorado River begins its journey in the Rocky Mountains, carrying sediment from alpine watersheds."
    scroll_position: 15
    side: "right"
---

<div class="river-container">
  
  <!-- Navigation -->
  <nav class="river-nav position-fixed top-0 start-0 p-3 w-25">
      {% include side-nav-banner.html %}
    
  </nav>

  <!-- Canvas River -->
  <canvas id="riverCanvas" class="river-canvas"></canvas>

  <!-- Tributary Points -->
  <div class="tributary-scroll-container">
    {% assign sorted_tributaries = site.tributaries | sort: "scroll_position" %}
    {% for tributary in sorted_tributaries %}
      <div class="tributary-step" 
           id="{{ tributary.title | downcase }}"
           data-step="{{ forloop.index0 }}"
           data-position="{{ tributary.position }}" 
           data-side="{{ tributary.side }}"
           style="top: {{ tributary.scroll_position }}px; height: 400px;">
        
        {% if tributary.side == 'left' %}
          <div class="tributary-content tributary-left">
            <div class="tributary-branch-left"></div>
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
          </div>
        {% else %}
          <div class="tributary-content tributary-right">
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
            <div class="tributary-branch-right"></div>
          </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>

  <!-- Feature Points -->
  {% for feature in page.features %}
    {% include river_feature.html feature=feature %}
  {% endfor %}
</div>

<style>
.river-container {
  position: relative;
  width: 100%;
  min-height: 5500px;
  background: linear-gradient(180deg, #F5DEB3 0%, #DEB887 30%, #D2691E 70%, #8B4513 100%);
  overflow-x: hidden;
}

.river-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.river-nav {
  z-index: 1000;

}

.nav-links {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.nav-link {
  text-decoration: none;
  font-size: 14px;
  color: #F5DEB3;
  transition: color 0.3s ease;
}

.nav-link:hover {
  color: #DEB887 !important;
}

.tributary-scroll-container {
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 100;
}

.tributary-step {
  position: absolute;
  width: 100%;
  z-index: 100;
}

.tributary-content {
  display: flex;
  align-items: center;
  opacity: 0;
  transform: translateY(50px);
  transition: all 0.8s ease;
}

.tributary-content.is-active {
  opacity: 1;
  transform: translateY(0);
}

.tributary-left {
  justify-content: flex-start;
  padding-left: 20px;
}

.tributary-right {
  justify-content: flex-end;
  padding-right: 20px;
}

.tributary-branch-left,
.tributary-branch-right {
  width: 100px;
  height: 3px;
  background: linear-gradient(90deg, #D2691E, transparent);
  position: relative;
}

.tributary-branch-right {
  background: linear-gradient(-90deg, #D2691E, transparent);
}

.content-box {
  background: rgba(245, 222, 179, 0.95);
  padding: 20px;
  border-radius: 12px;
  max-width: 300px;
  box-shadow: 0 8px 32px rgba(139, 69, 19, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(210, 105, 30, 0.3);
}

.content-box h3 {
  margin-bottom: 10px;
  color: #8B4513;
  font-size: 18px;
}

.content-box p {
  margin-bottom: 15px;
  font-size: 14px;
  line-height: 1.4;
  color: #5D4037;
}

.btn-outline-primary {
  border-color: #D2691E;
  color: #D2691E;
}

.btn-outline-primary:hover {
  background-color: #D2691E;
  border-color: #D2691E;
  color: white;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .tributary-left,
  .tributary-right {
    padding: 10px;
    justify-content: center;
  }
  
  .tributary-branch-left,
  .tributary-branch-right {
    display: none;
  }
  
  .content-box {
    max-width: 280px;
  }
}
</style>

<!-- Load Scrollama -->
<script src="{{ '/assets/lib/scrollama.js' | relative_url }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('riverCanvas');
  const ctx = canvas.getContext('2d');
  
  // Desert color palette
  const colors = {
    path: '#8B4513',
    particles: ['#CD853F', '#D2691E', '#F4A460', '#DEB887', '#BC8F8F', '#A0522D'],
    glow: '#F4A460'
  };
  
  // Set up canvas responsively
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = 5500;
  }
  
  resizeCanvas();
  
  // Parse the SVG path to canvas coordinates
  const pathString = "{{ page.river_path }}";
  
  function parsePathToPoints(pathStr) {
    const points = [];
    const commands = pathStr.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);
    let currentX = 0, currentY = 0;
    
    // Original SVG bounds
    const originalBounds = { minX: 0, maxX: 200, minY: -10, maxY: 400 };
    
    commands.forEach(command => {
      const type = command[0];
      const coords = command.slice(1).trim().split(/[\s,]+/).map(Number);
      
      if (type === 'M') {
        currentX = coords[0];
        currentY = coords[1];
        const scaledX = (currentX / originalBounds.maxX) * canvas.width;
        const scaledY = ((currentY - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
        points.push({x: scaledX, y: scaledY});
      } else if (type === 'Q') {
        const steps = 25;
        const startX = currentX, startY = currentY;
        const cpX = coords[0], cpY = coords[1];
        const endX = coords[2], endY = coords[3];
        
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = (1-t)*(1-t)*startX + 2*(1-t)*t*cpX + t*t*endX;
          const y = (1-t)*(1-t)*startY + 2*(1-t)*t*cpY + t*t*endY;
          const scaledX = (x / originalBounds.maxX) * canvas.width;
          const scaledY = ((y - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
          points.push({x: scaledX, y: scaledY});
        }
        
        currentX = endX;
        currentY = endY;
      } else if (type === 'T') {
        const steps = 15;
        const endX = coords[0], endY = coords[1];
        
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = currentX + t * (endX - currentX);
          const y = currentY + t * (endY - currentY);
          const scaledX = (x / originalBounds.maxX) * canvas.width;
          const scaledY = ((y - originalBounds.minY) / (originalBounds.maxY - originalBounds.minY)) * canvas.height;
          points.push({x: scaledX, y: scaledY});
        }
        
        currentX = endX;
        currentY = endY;
      }
    });
    
    return points;
  }
  
  let pathPoints = parsePathToPoints(pathString);
  
  // Particle class with settling behavior (using percentages)
  class Particle {
    constructor(x, y, isRiverBed = false) {
      // Store positions as percentages of canvas dimensions
      this.x = x / canvas.width; // Convert to percentage
      this.y = y / canvas.height; // Convert to percentage
      this.targetX = this.x;
      this.targetY = this.y;
      this.vx = isRiverBed ? 0 : (Math.random() - 0.5) * 0.0012; // Percentage-based velocity
      this.vy = isRiverBed ? 0 : Math.random() * 0.0008 + 0.0005; // Percentage-based velocity
      this.life = 1;
      this.decay = isRiverBed ? 0 : Math.random() * 0.008 + 0.002;
      this.size = (Math.random() * 1.2 + 0.5) / Math.min(canvas.width, canvas.height) * 1000; // Responsive size
      this.color = colors.particles[Math.floor(Math.random() * colors.particles.length)];
      this.isRiverBed = isRiverBed;
      this.settled = isRiverBed;
      this.distanceToRiver = Infinity;
    }
    
    update(drawnPoints) {
      if (!this.settled) {
        // Move particle
        this.x += this.vx;
        this.y += this.vy;
        
        // Find distance to nearest drawn river point (in percentage space)
        this.distanceToRiver = Infinity;
        let nearestPoint = null;
        
        for (let point of drawnPoints) {
          const pointX = point.x / canvas.width;
          const pointY = point.y / canvas.height;
          const dist = Math.sqrt(Math.pow(this.x - pointX, 2) + Math.pow(this.y - pointY, 2));
          if (dist < this.distanceToRiver) {
            this.distanceToRiver = dist;
            nearestPoint = {x: pointX, y: pointY};
          }
        }
        
        // Settle if close to river (doubled distance for larger river)
        if (this.distanceToRiver < 0.036 && nearestPoint) { // 0.036 * 2 for doubled size
          this.settled = true;
          this.targetX = nearestPoint.x + (Math.random() - 0.5) * 0.048; // 0.048 * 2 for doubled width
          this.targetY = nearestPoint.y + (Math.random() - 0.5) * 0.024; // 0.024 * 2 for doubled width
          this.vx *= 0.1;
          this.vy *= 0.1;
          this.decay = 0; // Stop decaying when settled
          this.life = 1;
        } else {
          // Decay if too far from river for too long
          this.life -= this.decay;
        }
        
        // Gravity toward river if detected (doubled range)
        if (this.distanceToRiver < 0.07 && nearestPoint) { // 0.07 * 2 for doubled attraction range
          const attraction = 0.05;
          const dx = nearestPoint.x - this.x;
          const dy = nearestPoint.y - this.y;
          this.vx += dx * attraction / this.distanceToRiver;
          this.vy += dy * attraction / this.distanceToRiver;
        }
      } else {
        // Gentle settling motion
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        this.x += dx * 0.05;
        this.y += dy * 0.05;
        
        // Gentle sway for settled particles
        const time = Date.now() * 0.001;
        this.x += Math.sin(time + this.targetX * 100) * 0.0001;
        this.y += Math.cos(time + this.targetY * 100) * 0.00005;
      }
    }
    
    draw() {
      if (this.life <= 0) return;
      
      ctx.save();
      ctx.globalAlpha = Math.min(this.life, this.settled ? 0.9 : 0.7);
      
      // Convert percentage coordinates back to pixels for drawing
      const pixelX = this.x * canvas.width;
      const pixelY = this.y * canvas.height;
      const pixelSize = this.size * Math.min(canvas.width, canvas.height) / 1000;
      
      // No glow - solid particles
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pixelX, pixelY, pixelSize, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  let particles = [];
  let riverBedParticles = [];
  let drawnPoints = [];
  let currentPointIndex = 0;
  let scrollProgress = 0;
  let timeProgress = 0;
  let lastScrollY = 0;
  let startTime = Date.now();
  
  // Create initial river bed particles at each path point
  function createRiverBed() {
    for (let i = 0; i < pathPoints.length; i += 1) { // More frequent points
      const point = pathPoints[i];
      // Create more particles around each point for wider river (doubled)
      for (let w = 0; w < 400; w++) { // Quadruple the particles for doubled river
        const offsetX = (Math.random() - 0.5) * 0.048; // 0.048 * 2 for doubled width (percentage)
        const offsetY = (Math.random() - 0.5) * 0.024; // 0.024 * 2 for doubled width (percentage)
        riverBedParticles.push(new Particle(
          point.x + offsetX * canvas.width, 
          point.y + offsetY * canvas.height, 
          true
        ));
      }
    }
  }
  
  function getScrollProgress() {
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight - windowHeight;
    const scrolled = window.pageYOffset;
    return Math.min(scrolled / documentHeight, 1);
  }
  
  function getTimeProgress() {
    const elapsed = (Date.now() - startTime) / 1000;
    return Math.min(elapsed / 25, 1); // total seconds of animation
  }
  
  function spawnParticles(x, y, count = 3) { // More particles
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = (Math.random() * 0.07 + 0.03) * canvas.width; // Doubled spawn area (percentage-based)
      const px = x + Math.cos(angle) * distance;
      const py = y + Math.sin(angle) * distance;
      particles.push(new Particle(px, py));
    }
  }
  
  function animate() {
    // Clear canvas with slight trail
    ctx.fillStyle = 'rgba(248, 245, 240, 0.08)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update progress
    scrollProgress = getScrollProgress();
    timeProgress = getTimeProgress();
    const revealProgress = Math.max(scrollProgress, timeProgress);
    
    // Draw path progressively
    const targetIndex = Math.floor(revealProgress * pathPoints.length);
    
    if (currentPointIndex < targetIndex && currentPointIndex < pathPoints.length) {
      const point = pathPoints[currentPointIndex];
      drawnPoints.push(point);
      
      // Spawn more settling particles at river edge
      if (Math.random() < 0.8) { // Higher spawn rate
        spawnParticles(point.x, point.y, 2); // More particles per spawn
      }
      
      currentPointIndex++;
    }
    
    // Update and draw river bed particles (only revealed ones)
    const revealedBedCount = Math.floor(revealProgress * riverBedParticles.length);
    for (let i = 0; i < revealedBedCount; i++) {
      const particle = riverBedParticles[i];
      particle.update(drawnPoints);
      particle.draw();
    }
    
    // Update and draw flowing particles
    particles = particles.filter(particle => {
      particle.update(drawnPoints);
      particle.draw();
      return particle.life > 0 || particle.settled;
    });
    
    // Occasionally spawn new particles along revealed river
    if (drawnPoints.length > 10 && Math.random() < 0.25) { // Higher spawn rate
      const randomPoint = drawnPoints[Math.floor(Math.random() * drawnPoints.length)];
      spawnParticles(randomPoint.x, randomPoint.y, 2); // More particles
    }
    
    requestAnimationFrame(animate);
  }
  
  // Initialize
  createRiverBed();
  
  // Start animation
  animate();
  
  // Handle window resize
  window.addEventListener('resize', () => {
    resizeCanvas();
    pathPoints = parsePathToPoints(pathString);
    drawnPoints = [];
    currentPointIndex = 0;
    // Clear and recreate river bed for new dimensions
    riverBedParticles = [];
    particles = []; // Clear flowing particles too
    createRiverBed();
  });
  
  // Handle scroll for particle generation
  window.addEventListener('scroll', () => {
    const currentScrollY = window.pageYOffset;
    if (currentScrollY > lastScrollY && scrollProgress > 0.02) {
      // Generate particles when scrolling down
      if (drawnPoints.length > 5 && Math.random() < 0.7) { // Higher spawn rate
        const randomPoint = drawnPoints[Math.floor(Math.random() * drawnPoints.length * 0.8)];
        spawnParticles(randomPoint.x, randomPoint.y, 2); // More particles
      }
    }
    lastScrollY = currentScrollY;
  });
  
  // Initialize Scrollama for tributary activation
  if (typeof scrollama !== 'undefined') {
    const scroller = scrollama();
    scroller
      .setup({
        step: '.tributary-step',
        offset: 0.6,
        debug: false
      })
      .onStepEnter((response) => {
        const content = response.element.querySelector('.tributary-content');
        if (content) {
          content.classList.add('is-active');
        }
      });
    
    window.addEventListener('resize', scroller.resize);
  }
});
</script>
