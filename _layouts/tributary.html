---
layout: default
---

{% assign tributary_side = page.tributary-side | default: "left" %}

<div class="tributary-container">
  <!-- Navigation back to main -->
 <nav class="river-nav position-fixed top-0 start-0 p-3 w-25">
      <div class="nav-links">
      <a href="{{ '/main.html#' | append: page.title | downcase | relative_url }}" class="nav-link">‚Üê Back to Main River</a>
    </div>
    
  </nav>

  <!-- Canvas River -->
  <canvas id="tributaryCanvas" class="tributary-canvas"></canvas>

  <!-- Content area -->
  <div class="tributary-content-area">
    <div class="container">
      <div class="row">
        {% if tributary_side == 'right' %}
         <div class="col-lg-1">
          <!-- River space on right -->
        </div>
        <div class="col-lg-10">
         <!-- <div class="tributary-header">
            <h1>{{ page.title }}</h1>
            <p class="lead">{{ page.description }}</p>
          </div>-->
          
          <div class="tributary-body">
            {{ content }}
          </div>
        </div>
        <div class="col-lg-1">
          <!-- River space on right -->
        </div>
        {% else %}
        <div class="col-lg-2">
          <!-- River space on left -->
        </div>
        <div class="col-lg-9">
         <!-- <div class="tributary-header">
            <h1>{{ page.title }}</h1>
            <p class="lead">{{ page.description }}</p>
          </div>-->
          
          <div class="tributary-body">
            {{ content }}
          </div>
        </div>
        {% endif %}
      </div>
    </div>
  </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('tributaryCanvas');
  const ctx = canvas.getContext('2d');
  const tributarySide = '{{ tributary_side }}';
  
  // Desert color palette matching main.html
  const colors = {
    path: '#8B4513',
    particles: ['#CD853F', '#D2691E', '#F4A460', '#DEB887', '#BC8F8F', '#A0522D'],
    glow: '#F4A460'
  };
  
  // Set up canvas responsively
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight);
  }
  
  resizeCanvas();
  
  // Generate tributary path based on side
  function generateTributaryPath() {
    const points = [];
    const canvasHeight = canvas.height;
    const canvasWidth = canvas.width;
    
    if (tributarySide === 'right') {
      // Right side tributary - flows down the right side
      const baseX = canvasWidth * 0.95; // 75% from left
      const startY = 0;
      const endY = canvasHeight - 100;
      const steps = 50;
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const y = startY + (endY - startY) * t;
        // Add some curvature for natural flow
        const curve = Math.sin(t * Math.PI * 3) * 30;
        const x = baseX + curve;
        points.push({x, y});
      }
    } else {
      // Left side tributary - flows down the left side (default)
      const baseX = canvasWidth * 0.05; // 25% from left
      const startY = 0;
      const endY = canvasHeight - 100;
      const steps = 50;
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const y = startY + (endY - startY) * t;
        // Add some curvature for natural flow
        const curve = Math.sin(t * Math.PI * 3) * 30;
        const x = baseX + curve;
        points.push({x, y});
      }
    }
    
    return points;
  }
  
  let pathPoints = generateTributaryPath();
  
  // Particle class (adapted from main.html)
  class Particle {
    constructor(x, y, isRiverBed = false) {
      this.x = x / canvas.width;
      this.y = y / canvas.height;
      this.targetX = this.x;
      this.targetY = this.y;
      this.vx = isRiverBed ? 0 : (Math.random() - 0.5) * 0.001;
      this.vy = isRiverBed ? 0 : Math.random() * 0.0008 + 0.0005;
      this.life = 1;
      this.decay = isRiverBed ? 0 : Math.random() * 0.008 + 0.002;
      this.size = (Math.random() * 1.2 + 0.5) / Math.min(canvas.width, canvas.height) * 1000;
      this.color = colors.particles[Math.floor(Math.random() * colors.particles.length)];
      this.isRiverBed = isRiverBed;
      this.settled = isRiverBed;
      this.distanceToRiver = Infinity;
    }
    
    update(drawnPoints) {
      if (!this.settled) {
        this.x += this.vx;
        this.y += this.vy;
        
        this.distanceToRiver = Infinity;
        let nearestPoint = null;
        
        for (let point of drawnPoints) {
          const pointX = point.x / canvas.width;
          const pointY = point.y / canvas.height;
          const dist = Math.sqrt(Math.pow(this.x - pointX, 2) + Math.pow(this.y - pointY, 2));
          if (dist < this.distanceToRiver) {
            this.distanceToRiver = dist;
            nearestPoint = {x: pointX, y: pointY};
          }
        }
        
        if (this.distanceToRiver < 0.03 && nearestPoint) {
          this.settled = true;
          this.targetX = nearestPoint.x + (Math.random() - 0.5) * 0.04;
          this.targetY = nearestPoint.y + (Math.random() - 0.5) * 0.02;
          this.vx *= 0.1;
          this.vy *= 0.1;
          this.decay = 0;
          this.life = 1;
        } else {
          this.life -= this.decay;
        }
        
        if (this.distanceToRiver < 0.06 && nearestPoint) {
          const attraction = 0.05;
          const dx = nearestPoint.x - this.x;
          const dy = nearestPoint.y - this.y;
          this.vx += dx * attraction / this.distanceToRiver;
          this.vy += dy * attraction / this.distanceToRiver;
        }
      } else {
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        this.x += dx * 0.05;
        this.y += dy * 0.05;
        
        const time = Date.now() * 0.001;
        this.x += Math.sin(time + this.targetX * 100) * 0.0001;
        this.y += Math.cos(time + this.targetY * 100) * 0.00005;
      }
    }
    
    draw() {
      if (this.life <= 0) return;
      
      ctx.save();
      ctx.globalAlpha = Math.min(this.life, this.settled ? 0.9 : 0.7);
      
      const pixelX = this.x * canvas.width;
      const pixelY = this.y * canvas.height;
      const pixelSize = this.size * Math.min(canvas.width, canvas.height) / 1000;
      
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pixelX, pixelY, pixelSize, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  let particles = [];
  let riverBedParticles = [];
  let drawnPoints = [];
  let currentPointIndex = 0;
  let startTime = Date.now();
  
  // Create river bed particles
  function createRiverBed() {
    for (let i = 0; i < pathPoints.length; i += 1) {
      const point = pathPoints[i];
      for (let w = 0; w < 200; w++) {
        const offsetX = (Math.random() - 0.5) * 0.04;
        const offsetY = (Math.random() - 0.5) * 0.02;
        riverBedParticles.push(new Particle(
          point.x + offsetX * canvas.width, 
          point.y + offsetY * canvas.height, 
          true
        ));
      }
    }
  }
  
  function getTimeProgress() {
    const elapsed = (Date.now() - startTime) / 1000;
    return Math.min(elapsed / 8, 1); // Faster loading - 8 seconds instead of 25
  }
  
  function spawnParticles(x, y, count = 2) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = (Math.random() * 0.05 + 0.02) * canvas.width;
      const px = x + Math.cos(angle) * distance;
      const py = y + Math.sin(angle) * distance;
      particles.push(new Particle(px, py));
    }
  }
  
  function animate() {
    ctx.fillStyle = 'rgba(248, 245, 240, 0.08)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const timeProgress = getTimeProgress();
    const targetIndex = Math.floor(timeProgress * pathPoints.length);
    
    if (currentPointIndex < targetIndex && currentPointIndex < pathPoints.length) {
      const point = pathPoints[currentPointIndex];
      drawnPoints.push(point);
      
      if (Math.random() < 0.7) {
        spawnParticles(point.x, point.y, 2);
      }
      
      currentPointIndex++;
    }
    
    const revealedBedCount = Math.floor(timeProgress * riverBedParticles.length);
    for (let i = 0; i < revealedBedCount; i++) {
      const particle = riverBedParticles[i];
      particle.update(drawnPoints);
      particle.draw();
    }
    
    particles = particles.filter(particle => {
      particle.update(drawnPoints);
      particle.draw();
      return particle.life > 0 || particle.settled;
    });
    
    if (drawnPoints.length > 10 && Math.random() < 0.2) {
      const randomPoint = drawnPoints[Math.floor(Math.random() * drawnPoints.length)];
      spawnParticles(randomPoint.x, randomPoint.y, 1);
    }
    
    requestAnimationFrame(animate);
  }
  
  createRiverBed();
  animate();
  
  window.addEventListener('resize', () => {
    resizeCanvas();
    pathPoints = generateTributaryPath();
    drawnPoints = [];
    currentPointIndex = 0;
    riverBedParticles = [];
    particles = [];
    createRiverBed();
    startTime = Date.now(); // Reset animation timer
  });
});
</script>
