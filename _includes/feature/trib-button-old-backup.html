{% comment %}

    Tributary Button with Particle Disintegration Effect

    Creates an interactive button that disintegrates into particles when clicked,
    simulating sediment flowing down the river before navigating to a tributary page.

    Basic example:
    {% include feature/trib-button.html trib="water" %}

    Full example with all options:
    {% include feature/trib-button.html trib="water" image="custom-image" text="Explore Water" centered="true" continue="/next-page" %}

    Options:
    - "trib" = tributary name (required) - matches the tributary slug in /tributaries/
    - "image" = custom image filename (optional) - if not provided, uses trib name (e.g., "water" looks for /objects/water.png)
    - "text" = custom button text (optional) - if not provided, displays "Branch off to {Trib Name}"
    - "hidetext" = hide the text completely (optional) - set to "true" to show only icon
    - "centered" = centers the button on the page (optional) - set to "true" to enable
    - "continue" = link for continue button (optional) - displays a "Continue" arrow on left side

    Note: Button position (left/right float) is automatically determined by the page's 
    "tributary-side" frontmatter variable. The button floats opposite to the flow side.

{%- endcomment -%}
{% assign flow_side = page.tributary-side | default: "left" %}
{% assign opposite_side = "right" %}
{% if flow_side == "right" %}
  {% assign opposite_side = "left" %}
{% endif %}

{% assign trib_name = include.trib | capitalize %}
{% assign trib_link = '/tributaries/' | append: include.trib | append: '/' | relative_url %}
<div class="row" {% if include.centered %}class="text-center mb-3"{%- endif -%} >
  <div class="col-6">
    {% unless include.no-continue %}
    <div class="continue-arrow-wrapper">
      <button class="continue-arrow-button" aria-label="Continue reading">
        <svg width="250" height="100" viewBox="0 0 250 100" xmlns="http://www.w3.org/2000/svg">
          <!-- Curved river-like path pointing downward -->
          <path d="M 125 -10 Q 100 30, 125 50 Q 150 70, 150 77"
                stroke="#9B6B6B"
                stroke-width="25"
                fill="none"
                stroke-linecap="butt"
                opacity="0.75"/>
          <!-- Arrowhead at bottom -->
          <polygon points="150,100 130,77 170,77" fill="#9B6B6B" opacity="0.75"/>
        </svg>
      </button>
      <p class="trib-button-text text-center fs-6" style="margin-top: 8px; color: #8B4513;">Continue</p>
    </div>
    {% endunless %}
  </div>
  <div class="col-6">
<div class="trib-button-container">
  <canvas class="trib-particle-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; display: none;"></canvas>
  <div class="trib-button-wrapper float-end" >
    <a href="{{ trib_link }}{% if include.anchor %}#{{ include.anchor }}{% endif %}"
       class="trib-button-link"
       data-trib="{{ include.trib }}"
       data-flow-side="{{ opposite_side }}"
       aria-label="Branch off to {{ trib_name }}">
      <img src="{% if include.image %}{{'/objects/' | append: include.image | append: '.png' | relative_url}}{% else %}{{'/objects/' | append: include.trib | append: '.png' | relative_url}}{% endif %}"
           class="trib-button-image"
           alt="{{ trib_name }}"
           style="transition: transform 0.3s ease;">
    </a>
    {% unless include.hidetext == "true" %}
    <p class="trib-button-text text-center fs-6" style="margin-top: 8px; color: #8B4513;">
      {% if include.text %} {{include.text}}{% else %}Branch off to {{ trib_name }}{% endif %}
    </p>
    {% endunless %}
  </div>
</div>
</div>
</div>

<style>
.trib-button-image:hover {
  transform: scale(1.05);
  cursor: pointer;
}

.trib-button-container {
  transition: opacity 0.7s ease;
}

.continue-arrow-wrapper {
  display: inline-block;
}

.continue-arrow-button {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  display: block;
  width: 250px;
  height: 100px;
}

.continue-arrow-button svg {
  transition: transform 0.3s ease;
}

.continue-arrow-button:hover svg {
  transform: translateY(3px);
}

.continue-arrow-text {
  margin-top: 8px;
  color: #8B4513;
  font-weight: 500;
}
</style>

<script>
(function() {
  const colors = {
    particles: ['#CD853F', '#D2691E', '#F4A460', '#DEB887', '#BC8F8F', '#A0522D']
  };

  class TribParticle {
    constructor(x, y, targetSide, color, size) {
      this.x = x;
      this.y = y;
      this.targetSide = targetSide;
      this.color = color;
      this.size = size;
      this.opacity = 1;
      this.life = 1;

      // River flow with variance
      this.vx = (targetSide === 'right' ? 1 : -1) * (Math.random() * 4 + 6);
      this.vy = Math.random() * 4 - 1.5;
      
      // Turbulence for water effect
      this.turbulence = Math.random() * 0.5;
    }

    update() {
      // Gradual slowdown
      this.vx *= 0.97;
      this.vy *= 0.97;
      
      // Gravity and turbulence
      this.vy += 0.15;
      this.vx += Math.sin(this.y * 0.02) * this.turbulence;

      this.x += this.vx;
      this.y += this.vy;

      // Fade particles as they exit viewport
      const margin = 100;
      if (this.x < -margin || this.x > window.innerWidth + margin || 
          this.y > window.innerHeight + margin) {
        this.life -= 0.08;
        this.opacity = Math.max(0, this.life);
      }
    }

    draw(ctx) {
      if (this.opacity <= 0) return;
      
      ctx.globalAlpha = this.opacity;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    isDead() {
      return this.opacity <= 0;
    }
  }

  function disintegrateImage(imgElement, targetLink, flowSide) {
    const canvas = document.querySelector('.trib-particle-canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvas.style.display = 'block';

    const rect = imgElement.getBoundingClientRect();
    const img = new Image();
    
    // Only set crossOrigin if image is from different domain
    const imgUrl = new URL(imgElement.src, window.location.href);
    if (imgUrl.origin !== window.location.origin) {
        img.crossOrigin = "anonymous";
    }

    function createParticles() {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = rect.width;
        tempCanvas.height = rect.height;
        tempCtx.drawImage(img, 0, 0, rect.width, rect.height);

        const particles = [];
        const sampleRate = 2.5;
        let useFallback = false;

        try {
            const imageData = tempCtx.getImageData(0, 0, rect.width, rect.height);

            for (let y = 0; y < rect.height; y += sampleRate) {
                for (let x = 0; x < rect.width; x += sampleRate) {
                    const index = (y * rect.width + x) * 4;
                    const alpha = imageData.data[index + 3];

                    // Lower threshold for transparent images
                    if (alpha > 20) {
                        const r = imageData.data[index];
                        const g = imageData.data[index + 1];
                        const b = imageData.data[index + 2];
                        const color = `rgba(${r},${g},${b},${alpha/255})`;

                        const particleX = rect.left + x;
                        const particleY = rect.top + y;
                        const size = Math.random() * 2.5 + 1.5;

                        particles.push(new TribParticle(particleX, particleY, flowSide, color, size));
                    }
                }
            }
            
            // If very few particles, use fallback
            if (particles.length < 50) {
                useFallback = true;
            }
        } catch(e) {
            useFallback = true;
        }

        // Enhanced fallback for CORS issues or small images
        if (useFallback) {
            particles.length = 0; // Clear any existing particles
            const particleCount = Math.max(120, (rect.width * rect.height) / 25);
            
            for (let i = 0; i < particleCount; i++) {
                const particleX = rect.left + Math.random() * rect.width;
                const particleY = rect.top + Math.random() * rect.height;
                const color = colors.particles[Math.floor(Math.random() * colors.particles.length)];
                const size = Math.random() * 2.5 + 1.5;

                particles.push(new TribParticle(particleX, particleY, flowSide, color, size));
            }
        }

        // Hide image and fade page
        imgElement.style.opacity = '0';
        document.body.style.transition = 'opacity 0.5s ease';
        document.body.style.opacity = '0.7';

        let startTime = Date.now();
        const totalDuration = 1400;

        function animate() {
            const elapsed = Date.now() - startTime;
            ctx.fillStyle = 'rgba(248, 245, 240, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            if (elapsed >= totalDuration || particles.length === 0) {
                // Immediately hide everything
                document.body.style.transition = 'none';
                document.body.style.opacity = '0';
                canvas.style.display = 'none';
                
                // Brief delay to ensure fade is applied before navigation
                setTimeout(function() {
                    window.location.href = targetLink;
                }, 50);
            } else {
                requestAnimationFrame(animate);
            }
        }

        animate();
    }

    // Handle both cached and uncached images
    if (img.complete || imgElement.complete) {
        img.src = imgElement.src;
        // Image already loaded, start immediately
        setTimeout(createParticles, 0);
    } else {
        img.onload = createParticles;
        img.onerror = function() {
            // Still show effect even on error
            createParticles();
        };
        img.src = imgElement.src;
    }
}

  document.addEventListener('DOMContentLoaded', function() {
    const tribButtons = document.querySelectorAll('.trib-button-link');

    tribButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        const imgElement = this.querySelector('.trib-button-image');
        const targetLink = this.getAttribute('href');
        const flowSide = this.getAttribute('data-flow-side');

        disintegrateImage(imgElement, targetLink, flowSide);
      });
    });

    // Continue button scroll functionality
    const continueButtons = document.querySelectorAll('.continue-arrow-button');

    continueButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();

        // Find the trib-button row container
        const buttonRow = this.closest('.row');

        if (buttonRow) {
          // Look for next meaningful content section
          let targetElement = buttonRow.nextElementSibling;

          // Skip whitespace and empty text nodes
          while (targetElement && (targetElement.nodeType !== 1 || !targetElement.offsetHeight)) {
            targetElement = targetElement.nextElementSibling;
          }

          // If no direct sibling, search within parent container
          if (!targetElement) {
            const parent = buttonRow.parentElement;
            if (parent) {
              // Find all subsequent sections/divs
              const allSections = parent.querySelectorAll('section, .row, .container, div[id], div[class*="content"]');
              const currentIndex = Array.from(parent.children).indexOf(buttonRow);

              // Get elements after current button
              for (let section of allSections) {
                const sectionIndex = Array.from(parent.children).indexOf(section);
                if (sectionIndex > currentIndex && section.offsetHeight > 0) {
                  targetElement = section;
                  break;
                }
              }
            }
          }

          // Fallback: scroll down by viewport height
          if (!targetElement) {
            window.scrollBy({
              top: window.innerHeight * 0.8,
              behavior: 'smooth'
            });
          } else {
            // Smooth scroll to target with offset for better visibility
            const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - 20;
            window.scrollTo({
              top: targetPosition,
              behavior: 'smooth'
            });
          }
        }
      });
    });
  });
})();
</script>