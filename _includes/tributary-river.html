{% assign side = include.side | default: "left" %}
{% assign river_id = include.id | default: "tributary" %}

<svg class="tributary-river" 
     width="100%" 
     height="100%" 
     preserveAspectRatio="none" 
     style="position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;">
    
    <defs>
        <!-- River base gradient for curved column -->
        <linearGradient id="tributaryBase{{ river_id }}" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:rgba(139,115,85,0.1);stop-opacity:1" />
            <stop offset="20%" style="stop-color:rgba(160,132,92,0.4);stop-opacity:1" />
            <stop offset="50%" style="stop-color:rgba(160,132,92,0.6);stop-opacity:1" />
            <stop offset="80%" style="stop-color:rgba(160,132,92,0.4);stop-opacity:1" />
            <stop offset="100%" style="stop-color:rgba(139,115,85,0.1);stop-opacity:1" />
        </linearGradient>
        
        <!-- Flowing particles pattern -->
        <pattern id="particlePattern{{ river_id }}" x="0" y="0" width="60" height="80" patternUnits="userSpaceOnUse">
            <circle cx="10" cy="10" r="1.5" fill="#CD853F" opacity="0.5"/>
            <circle cx="45" cy="20" r="1.2" fill="#D2691E" opacity="0.6"/>
            <circle cx="25" cy="35" r="1.8" fill="#DEB887" opacity="0.4"/>
            <circle cx="50" cy="45" r="1" fill="#BC8F8F" opacity="0.5"/>
            <circle cx="15" cy="60" r="1.3" fill="#F4A460" opacity="0.45"/>
            <circle cx="38" cy="70" r="1.6" fill="#CD853F" opacity="0.55"/>
            <circle cx="30" cy="15" r="0.8" fill="#A0522D" opacity="0.3"/>
            <circle cx="20" cy="50" r="0.7" fill="#D2691E" opacity="0.35"/>
            <circle cx="40" cy="30" r="0.9" fill="#DEB887" opacity="0.3"/>
        </pattern>
        
        <!-- Flow streaks -->
        <pattern id="flowStreaks{{ river_id }}" x="0" y="0" width="40" height="100" patternUnits="userSpaceOnUse">
            <line x1="10" y1="0" x2="12" y2="25" stroke="rgba(139,115,85,0.15)" stroke-width="1" stroke-linecap="round"/>
            <line x1="25" y1="20" x2="27" y2="50" stroke="rgba(160,132,92,0.12)" stroke-width="0.8" stroke-linecap="round"/>
            <line x1="35" y1="40" x2="36" y2="70" stroke="rgba(139,115,85,0.1)" stroke-width="1.2" stroke-linecap="round"/>
            <line x1="15" y1="60" x2="17" y2="90" stroke="rgba(160,132,92,0.15)" stroke-width="0.9" stroke-linecap="round"/>
        </pattern>
                
    </defs>
    
    {% if side == "right" %}
    <!-- Right side tributary - curves naturally down the right -->
    <g id="riverGroup{{ river_id }}" class="river-group" data-side="right">
        <!-- Main river path with curves -->
        <path id="riverPath{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#tributaryBase{{ river_id }})" 
              filter="url(#ripple{{ river_id }})"
              class="tributary-base tributary-path"
              opacity="1"/>
        
        <!-- Particle flow overlay -->
        <path id="riverPathParticles{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#particlePattern{{ river_id }})" 
              class="tributary-particles tributary-path"
              opacity="1"/>
        
        <!-- Flow streaks overlay -->
        <path id="riverPathStreaks{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#flowStreaks{{ river_id }})" 
              opacity="0.7"
              class="tributary-streaks tributary-path"/>
    </g>
    
    {% else %}
    <!-- Left side tributary - curves naturally down the left (default) -->
    <g id="riverGroup{{ river_id }}" class="river-group" data-side="left">
        <!-- Main river path with curves -->
        <path id="riverPath{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#tributaryBase{{ river_id }})" 
              filter="url(#ripple{{ river_id }})"
              class="tributary-base tributary-path"
              opacity="1"/>
        
        <!-- Particle flow overlay -->
        <path id="riverPathParticles{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#particlePattern{{ river_id }})" 
              class="tributary-particles tributary-path"
              opacity="1"/>
        
        <!-- Flow streaks overlay -->
        <path id="riverPathStreaks{{ river_id }}" 
              d="M 0 0 L 0 100" 
              fill="url(#flowStreaks{{ river_id }})" 
              opacity="0.7"
              class="tributary-streaks tributary-path"/>
    </g>
    {% endif %}
</svg>

<script>
(function() {
  const riverGroup = document.querySelector('.river-group');
  if (!riverGroup) {
    console.log('No river group found');
    return;
  }
  
  const side = riverGroup.getAttribute('data-side');
  const svgElement = document.querySelector('.tributary-river');
  
  console.log('River initialized, side:', side);
  
  // Generate organic curved path
  function generateRiverPath() {
    const viewportHeight = Math.max(
      document.documentElement.scrollHeight,
      document.documentElement.clientHeight,
      window.innerHeight
    );
    
    const svgHeight = viewportHeight;
    const svgWidth = window.innerWidth;
    
    // Update SVG viewBox to match document
    svgElement.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
    svgElement.style.height = svgHeight + 'px';
    
    // River width (75% of original = 6% * 0.75 = 4.5% for right, 8% * 0.75 = 6% for left)
    const riverWidth = side === 'right' ? svgWidth * 0.045 : svgWidth * 0.06;
    
    // Base position
    const baseX = side === 'right' ? svgWidth * 0.95 : svgWidth * 0.065;
    
    // Generate points with organic curves using seeded randomness
    const points = [];
    const segments = Math.ceil(svgHeight / 60);
    
    // Use a simple seeded random for consistency
    let seed = 12345;
    function seededRandom() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    
    for (let i = 0; i <= segments; i++) {
      const y = (i / segments) * svgHeight;
      
      // Create organic curves - use sine waves combined with seeded random
      const curveFactor = Math.sin(i * 0.3) * 0.6 + Math.sin(i * 0.15) * 0.4;
      const randomOffset = (seededRandom() - 0.5) * 0.3;
      const totalCurve = (curveFactor + randomOffset) * riverWidth * 1.5;
      
      const centerX = baseX + totalCurve;
      
      points.push({ x: centerX, y: y });
    }
    
    // Build the path string using smooth curves
    let pathData = '';
    
    // Start from top left edge
    pathData += `M ${points[0].x - riverWidth/2} ${points[0].y} `;
    
    // Draw left edge with smooth curves
    for (let i = 1; i < points.length; i++) {
      const prev = points[i - 1];
      const curr = points[i];
      
      // Quadratic bezier for smooth curves
      const cpY = prev.y + (curr.y - prev.y) / 2;
      const cpX = prev.x - riverWidth/2 + (curr.x - prev.x) / 2;
      
      pathData += `Q ${cpX} ${cpY}, ${curr.x - riverWidth/2} ${curr.y} `;
    }
    
    // Draw bottom edge
    const lastPoint = points[points.length - 1];
    pathData += `L ${lastPoint.x + riverWidth/2} ${lastPoint.y} `;
    
    // Draw right edge back up with smooth curves
    for (let i = points.length - 1; i > 0; i--) {
      const curr = points[i];
      const prev = points[i - 1];
      
      const cpY = curr.y - (curr.y - prev.y) / 2;
      const cpX = curr.x + riverWidth/2 + (prev.x - curr.x) / 2;
      
      pathData += `Q ${cpX} ${cpY}, ${prev.x + riverWidth/2} ${prev.y} `;
    }
    
    pathData += 'Z';
    
    console.log('Generated path, segments:', segments, 'width:', riverWidth);
    return pathData;
  }
  
  // Set initial path
  setTimeout(function() {
    const pathData = generateRiverPath();
    document.querySelectorAll('.tributary-path').forEach(path => {
      path.setAttribute('d', pathData);
    });
    console.log('Path set');
    
    // Initial reveal - start with 20% visible
    updateRiverReveal();
  }, 100);
  
  let ticking = false;
  
  function updateRiverReveal() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const scrollPercent = docHeight > 0 ? Math.min(scrollTop / docHeight, 1) : 0;
    
    // Start at 20% visible, reveal fully by 80% scroll
    const minReveal = 0.2;
    const revealPercent = Math.min(minReveal + (scrollPercent * 0.8), 1);
    const hidePercent = Math.max(0, 100 - (revealPercent * 100));
    
    riverGroup.style.clipPath = `inset(0 0 ${hidePercent}% 0)`;
    
    ticking = false;
  }
  
  function requestTick() {
    if (!ticking) {
      requestAnimationFrame(updateRiverReveal);
      ticking = true;
    }
  }
  
  // Listen for scroll events
  window.addEventListener('scroll', requestTick, { passive: true });
  
  // Regenerate path on resize
  let resizeTimeout;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      const newPathData = generateRiverPath();
      document.querySelectorAll('.tributary-path').forEach(path => {
        path.setAttribute('d', newPathData);
      });
      updateRiverReveal();
    }, 250);
  }, { passive: true });
})();
</script>