---
layout: default
title: "The Colorado River Journey"
river_path: "M190,-10 Q105,0 100,0 T65,15 50,23 Q45,25 30,35 Q20,45 19,65 Q22,75 20,85 Q17,95 19,105 Q22,115 20,125 Q17,135 19,145 Q22,155 20,165 Q17,175 19,185 Q22,195 20,205 Q17,215 19,225 Q22,235 20,245 Q17,255 19,265 Q22,275 20,285 Q17,295 19,305 Q22,310 20,320 Q17,330 19,340 Q22,350 20,360 Q17,385 19,400"
features:
  - type: "text-block"
    id: "river-source"
    title: "River Source"
    content: "The Colorado River begins its journey in the Rocky Mountains, carrying sediment from alpine watersheds."
    scroll_position: 15
    side: "right"
---

<div class="river-container">
  <!-- Navigation -->
  <nav class="river-nav position-fixed top-0 start-0 p-3">
    <div class="nav-links">
      <a href="#about-project" class="nav-link">About the Project</a>
      <a href="#about-river" class="nav-link">About the Colorado River/Glen Canyon Dam</a>
      <a href="#about-sediment" class="nav-link">About Sediment</a>
    </div>
  </nav>

        <!-- River SVG Container -->
  <div class="river-flow-container">
    <svg id="riverSvg" class="river-svg" width="100%" height="100%" viewBox="0 0 200 420" preserveAspectRatio="xMidYMin meet">
      <!-- River path definition -->
      <defs>
        <path id="riverPath" d="{{ page.river_path }}"/>
        
        <!-- Tributary path definitions -->
        <path id="tributary1" d="M18,45 Q12,43 6,41 Q0,39 -6,37"/>
        <path id="tributary2" d="M20,85 Q26,83 32,81 Q38,79 44,77"/>
        <path id="tributary3" d="M19,125 Q13,123 7,121 Q1,119 -5,117"/>
        <path id="tributary4" d="M20,165 Q26,163 32,161 Q38,159 44,157"/>
        <path id="tributary5" d="M19,205 Q13,203 7,201 Q1,199 -5,197"/>
        <path id="tributary6" d="M20,245 Q26,243 32,241 Q38,239 44,237"/>
        <path id="tributary7" d="M19,285 Q13,283 7,281 Q1,279 -5,277"/>
        
        <!-- Clipping path for river area -->
        <clipPath id="riverClip">
          <path d="{{ page.river_path }}" stroke-width="20" stroke="white" fill="none"/>
        </clipPath>
        
        <!-- Particle definitions with southwest canyon colors -->
        <circle id="sedimentParticle1" r="0.3" fill="#D2691E" opacity="0.8"/>
        <circle id="sedimentParticle2" r="0.25" fill="#CD853F" opacity="0.7"/>
        <circle id="sedimentParticle3" r="0.2" fill="#DEB887" opacity="0.6"/>
        <circle id="sedimentParticle4" r="0.35" fill="#F4A460" opacity="0.8"/>
        <circle id="sedimentParticle5" r="0.15" fill="#A0522D" opacity="0.9"/>
        <circle id="sedimentParticle6" r="0.28" fill="#8B4513" opacity="0.7"/>
        <circle id="tributaryParticle1" r="0.2" fill="#CD853F" opacity="0.6"/>
        <circle id="tributaryParticle2" r="0.15" fill="#DEB887" opacity="0.5"/>
        <circle id="tributaryParticle3" r="0.25" fill="#F4A460" opacity="0.7"/>
      </defs>
      
      <!-- Group for particles with clipping -->
      <g id="particleGroup" clip-path="url(#riverClip)"></g>
      
      <!-- Group for flowing particles (before they hit river) -->
      <g id="flowingGroup"></g>
    </svg>
  </div>

  <!-- Tributary Points -->
  <div class="tributary-scroll-container">
    {% assign sorted_tributaries = site.tributaries | sort: "scroll_position" %}
    {% for tributary in sorted_tributaries %}
      <div class="tributary-step" 
           id="{{ tributary.title | downcase }}"
           data-step="{{ forloop.index0 }}"
           data-position="{{ tributary.position }}" 
           data-side="{{ tributary.side }}"
           style="top: {{ tributary.scroll_position }}px; height: 400px;">
        
        {% if tributary.side == 'left' %}
          <div class="tributary-content tributary-left">
            <div class="tributary-branch-left"></div>
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
          </div>
        {% else %}
          <div class="tributary-content tributary-right">
            <div class="content-box">
              <h3>{{ tributary.title }}</h3>
              <p>{{ tributary.description }}</p>
              <a href="{{ tributary.url | relative_url }}" class="btn btn-outline-primary btn-sm">Explore →</a>
            </div>
            <div class="tributary-branch-right"></div>
          </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>

  <!-- Feature Points -->
  {% for feature in page.features %}
    {% include river_feature.html feature=feature %}
  {% endfor %}
</div>

<style>
.river-container {
  position: relative;
  width: 100%;
  min-height: 5500px;
  background: linear-gradient(180deg, #F5DEB3 0%, #DEB887 30%, #D2691E 70%, #8B4513 100%);
  overflow-x: hidden;
}

.river-nav {
  z-index: 1000;
  background: rgba(139, 69, 19, 0.8);
  border-radius: 8px;
  backdrop-filter: blur(10px);
}

.nav-links {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.nav-link {
  text-decoration: none;
  font-size: 14px;
  color: #F5DEB3;
  transition: color 0.3s ease;
}

.nav-link:hover {
  color: #DEB887 !important;
}

.river-flow-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.river-svg {
  width: 100%;
  height: 100%;
}

.tributary-scroll-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.tributary-step {
  position: absolute;
  width: 100%;
  z-index: 100;
}

.tributary-content {
  display: flex;
  align-items: center;
  opacity: 0;
  transform: translateY(50px);
  transition: all 0.8s ease;
}

.tributary-content.is-active {
  opacity: 1;
  transform: translateY(0);
}

.tributary-left {
  justify-content: flex-start;
  padding-left: 20px;
}

.tributary-right {
  justify-content: flex-end;
  padding-right: 20px;
}

.tributary-branch-left,
.tributary-branch-right {
  width: 100px;
  height: 3px;
  background: linear-gradient(90deg, #D2691E, transparent);
  position: relative;
}

.tributary-branch-right {
  background: linear-gradient(-90deg, #D2691E, transparent);
}

.content-box {
  background: rgba(245, 222, 179, 0.95);
  padding: 20px;
  border-radius: 12px;
  max-width: 300px;
  box-shadow: 0 8px 32px rgba(139, 69, 19, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(210, 105, 30, 0.3);
}

.content-box h3 {
  margin-bottom: 10px;
  color: #8B4513;
  font-size: 18px;
}

.content-box p {
  margin-bottom: 15px;
  font-size: 14px;
  line-height: 1.4;
  color: #5D4037;
}

.btn-outline-primary {
  border-color: #D2691E;
  color: #D2691E;
}

.btn-outline-primary:hover {
  background-color: #D2691E;
  border-color: #D2691E;
  color: white;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .tributary-left,
  .tributary-right {
    padding: 10px;
    justify-content: center;
  }
  
  .tributary-branch-left,
  .tributary-branch-right {
    display: none;
  }
  
  .content-box {
    max-width: 280px;
  }
}
</style>

<!-- Load Scrollama -->
<script src="{{ '/assets/lib/scrollama.js' | relative_url }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const svg = document.getElementById('riverSvg');
  const riverPath = document.getElementById('riverPath');
  const particleGroup = document.getElementById('particleGroup');
  const flowingGroup = document.getElementById('flowingGroup');
  const particles = [];
  const tributaryParticles = [];
  const riverBedParticles = [];
  let scrollProgress = 0;
  let timeProgress = 0;
  let lastScrollY = 0;
  let startTime = Date.now();
  let particlesReachedBottom = false;
  
  // Particle types for variety
  const particleTypes = ['sedimentParticle1', 'sedimentParticle2', 'sedimentParticle3', 'sedimentParticle4', 'sedimentParticle5', 'sedimentParticle6'];
  const tributaryParticleTypes = ['tributaryParticle1', 'tributaryParticle2', 'tributaryParticle3'];
  
  // Get path length for calculations
  const pathLength = riverPath.getTotalLength();
  
  // Tributary paths
  const tributaryPaths = [
    'tributary1', 'tributary2', 'tributary3', 'tributary4', 
    'tributary5', 'tributary6', 'tributary7'
  ];
  
  // Pre-calculate river points for efficient lookup
  const riverPoints = [];
  for (let i = 0; i <= pathLength; i += 1) {
    const point = riverPath.getPointAtLength(i);
    riverPoints.push({
      x: point.x,
      y: point.y,
      progress: (i / pathLength) * 100
    });
  }
  
  // Create dense river bed particles that form the visible shape
  function createRiverBed() {
    const bedDensity = 1200; // Even more particles for better visibility
    
    for (let i = 0; i < bedDensity; i++) {
      const progress = (i / bedDensity) * 100;
      const distance = (progress / 100) * pathLength;
      const point = riverPath.getPointAtLength(distance);
      
      // Create narrower river with better-confined particles
      for (let width = 0; width < 8; width++) {
        const particleType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
        use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + particleType);
        
        // Calculate perpendicular offset for river width
        const nextDistance = Math.min(distance + 2, pathLength);
        const nextPoint = riverPath.getPointAtLength(nextDistance);
        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
        const perpAngle = angle + Math.PI / 2;
        
        const riverWidth = 8; // Slightly narrower river with tighter particle placement
        const widthOffset = ((width / 7) - 0.5) * riverWidth + (Math.random() - 0.5) * 2;
        const offsetX = Math.cos(perpAngle) * widthOffset;
        const offsetY = Math.sin(perpAngle) * widthOffset;
        
        // Start particles closer to their final position
        const startDistance = 20 + Math.random() * 30; // Shorter distance to travel
        const startAngle = Math.atan2(point.y - 0, point.x - 100) + (Math.random() - 0.5) * 0.5;
        
        // Calculate current position first
        const currentX = point.x + Math.cos(startAngle) * startDistance;
        const currentY = point.y + Math.sin(startAngle) * startDistance;
        
        // Calculate drift after we know the current position
        const horizontalDrift = (point.x - currentX) / startDistance * 0.8;
        
        const particle = {
          element: use,
          targetX: point.x + offsetX,
          targetY: point.y + offsetY,
          currentX: currentX,
          currentY: currentY,
          progress: progress,
          revealed: false,
          fallSpeed: 2.5 + Math.random() * 1.0, // Much faster fall
          horizontalDrift: horizontalDrift,
          settled: false,
          visible: false
        };
        
        use.setAttribute('transform', `translate(${particle.currentX}, ${particle.currentY})`);
        use.setAttribute('opacity', '0');
        particleGroup.appendChild(use); // Add to clipped group
        riverBedParticles.push(particle);
      }
    }
  }
  
  // Create flowing particles for continuous animation
  function createFlowingParticle() {
    const particleType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
    const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + particleType);
    
    // Find a random point on the already revealed part of the river
    const currentRevealProgress = Math.max(timeProgress, scrollProgress) * 100;
    let startPoint = riverPoints[0];
    
    if (currentRevealProgress > 5) {
      // Find a point along the revealed section
      const revealedIndex = Math.floor((riverPoints.length - 1) * (currentRevealProgress / 100) * 0.8);
      const randomIndex = Math.floor(Math.random() * revealedIndex);
      startPoint = riverPoints[randomIndex];
    }
    
    // Start closer to the river path with more controlled velocity
    const offsetDistance = 15 + Math.random() * 10;
    const offsetAngle = Math.random() * Math.PI * 2;
    
    const particle = {
      element: use,
      x: startPoint.x + Math.cos(offsetAngle) * offsetDistance,
      y: startPoint.y + Math.sin(offsetAngle) * offsetDistance,
      vx: -0.3 - Math.random() * 0.3, // Less horizontal velocity
      vy: 0.6 + Math.random() * 0.4, // Less vertical velocity
      life: 1.0,
      lifetime: 0, // Track how long particle has existed
      maxLifetime: 120, // Disappear after this many frames if not in river
      onRiver: false,
      riverProgress: 0,
      riverSpeed: 0.4 + Math.random() * 0.3,
      settled: false
    };
    
    use.setAttribute('transform', `translate(${particle.x}, ${particle.y})`);
    use.setAttribute('opacity', '0.8');
    
    // Only add to DOM if within bounds
    if (particle.x >= -10 && particle.x <= 210 && particle.y >= -10 && particle.y <= 430) {
      flowingGroup.appendChild(use);
      particles.push(particle);
      return particle;
    } else {
      // Discard out-of-bounds particles
      return null;
    }
  }
  
  // Check if point is near revealed river sections
  function isNearRevealedRiver(x, y, tolerance = 8) {
    const currentRevealProgress = Math.max(timeProgress, scrollProgress) * 100;
    
    for (let point of riverPoints) {
      if (point.progress <= currentRevealProgress) {
        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
        if (distance <= tolerance) {
          return { near: true, progress: point.progress };
        }
      }
    }
    return { near: false, progress: 0 };
  }
  
  // Get scroll progress
  function updateScrollProgress() {
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight - windowHeight;
    const scrolled = window.pageYOffset;
    scrollProgress = Math.min(scrolled / documentHeight, 1);
  }
  
  // Update time-based progress with dynamic speed
  function updateTimeProgress() {
    const elapsed = (Date.now() - startTime) / 1000; // seconds
    
    // Speed up initially, slow down after particles reach bottom
    if (!particlesReachedBottom) {
      // Fast initial 2-second build (was 4 seconds)
      timeProgress = Math.min(elapsed / 2, 1);
      // Check if particles have reached bottom 85% of screen
      if (timeProgress > 0.85) {
        particlesReachedBottom = true;
      }
    } else {
      // Faster progression after initial build
      const slowElapsed = elapsed - 2; // Time after initial 2 seconds
      timeProgress = Math.min(1, 0.85 + (slowElapsed / 4)); // Faster for remaining 15%
    }
  }
  
  // Animate all particles
  function animateParticles() {
    updateScrollProgress();
    updateTimeProgress();
    
    // Current reveal threshold - starts with time, enhanced by scroll
    const revealThreshold = Math.max(timeProgress, scrollProgress) * 100;
    
    // Animate river bed particles - these carve out the river shape
    riverBedParticles.forEach((particle, index) => {
      // Should this particle be revealed based on time + scroll progress?
      if (!particle.revealed && revealThreshold >= particle.progress) {
        particle.revealed = true;
      }
      
      if (particle.revealed && !particle.settled) {
        // Animate particle falling and settling into river bed
        particle.currentX += particle.horizontalDrift;
        particle.currentY += particle.fallSpeed;
        
        // Check if particle has reached its target position
        const distanceToTarget = Math.sqrt(
          Math.pow(particle.currentX - particle.targetX, 2) + 
          Math.pow(particle.currentY - particle.targetY, 2)
        );
        
        if (distanceToTarget < 3 || particle.currentY >= particle.targetY) {
          // Particle has settled
          particle.currentX = particle.targetX;
          particle.currentY = particle.targetY;
          particle.settled = true;
          particle.visible = true;
        }
        
        particle.element.setAttribute('transform', `translate(${particle.currentX}, ${particle.currentY})`);
        
        // Fade in as particle settles
        const opacity = particle.settled ? 0.9 : Math.min(0.6, distanceToTarget / 20);
        particle.element.setAttribute('opacity', opacity);
      } else if (particle.settled && particle.visible) {
        // Keep settled particles visible with gentle sway
        const sway = Math.sin(Date.now() * 0.001 + index * 0.1) * 0.3;
        particle.element.setAttribute('transform', `translate(${particle.targetX + sway}, ${particle.targetY + sway * 0.2})`);
        particle.element.setAttribute('opacity', '0.9');
      }
    });
    
    // Animate flowing particles
    particles.forEach((particle, index) => {
      if (!particle.onRiver && !particle.settled) {
        // Move particle in falling trajectory
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.lifetime++;
        
        // Check if particle hits the revealed river area
        const riverCheck = isNearRevealedRiver(particle.x, particle.y);
        if (riverCheck.near) {
          particle.onRiver = true;
          particle.riverProgress = riverCheck.progress;
          particle.settled = true;
          
          // Move particle to clipped group when it settles
          if (particle.element.parentNode) {
            particle.element.parentNode.removeChild(particle.element);
          }
          particleGroup.appendChild(particle.element);
        }
        
        // Remove if goes off screen or exists too long without hitting river
        if (particle.x < -20 || particle.x > 220 || particle.y < -20 || particle.y > 430 || particle.lifetime > particle.maxLifetime) {
          if (particle.element.parentNode) {
            particle.element.parentNode.removeChild(particle.element);
          }
          particles.splice(index, 1);
          return;
        }
        
        // Fade out particles that are straying too far from the river
        const nearestRiverPoint = isNearRevealedRiver(particle.x, particle.y, 30);
        if (!nearestRiverPoint.near) {
          // Gradually reduce opacity the longer it exists
          const newOpacity = Math.max(0, 0.8 - (particle.lifetime / particle.maxLifetime));
          particle.element.setAttribute('opacity', newOpacity);
        }
      } else if (particle.onRiver && particle.settled) {
        // Particle is now part of the river - stay in place with slight movement
        const distance = (particle.riverProgress / 100) * pathLength;
        const point = riverPath.getPointAtLength(distance);
        
        // Add gentle swaying motion
        const sway = Math.sin(Date.now() * 0.003 + index) * 0.5;
        particle.x = point.x + sway;
        particle.y = point.y + sway * 0.3;
        
        particle.element.setAttribute('opacity', '0.8');
      }
      
      particle.element.setAttribute('transform', `translate(${particle.x}, ${particle.y})`);
    });
    
    // Dynamic particle creation based on progress
    let creationRate = 0.6; // Default rate
    if (!particlesReachedBottom) {
      creationRate = 0.8; // Higher rate during fast build phase
    } else {
      creationRate = 0.3; // Lower rate after initial build
    }
    
    // Create new flowing particles
    if (Math.random() < creationRate) {
      createFlowingParticle();
    }
    
    // Create extra particles when scrolling
    if (scrollProgress > 0.02 && Math.random() < 0.4) {
      createFlowingParticle();
    }
    
    requestAnimationFrame(animateParticles);
  }
  
  // Initialize river bed particles
  createRiverBed();
  
  // Create initial controlled burst of flowing particles
  for (let i = 0; i < 30; i++) { // Reduced from 100
    setTimeout(() => createFlowingParticle(), i * 30); // Faster creation
  }
  
  // Start animation
  animateParticles();
  
  // Create regular particle bursts with dynamic timing
  setInterval(() => {
    const burstSize = particlesReachedBottom ? 2 : 4; // Fewer particles after initial build
    for (let i = 0; i < burstSize; i++) {
      createFlowingParticle();
    }
  }, particlesReachedBottom ? 300 : 150); // Slower interval after initial build
  
  // Handle scroll for more particle generation
  window.addEventListener('scroll', () => {
    const currentScrollY = window.pageYOffset;
    if (currentScrollY > lastScrollY && scrollProgress > 0.02) {
      // Generate more particles when scrolling down
      for (let i = 0; i < 4; i++) {
        setTimeout(() => createFlowingParticle(), i * 25);
      }
    }
    lastScrollY = currentScrollY;
  });
  
  // Initialize Scrollama for tributary activation (simplified for now)
  if (typeof scrollama !== 'undefined') {
    const scroller = scrollama();
    scroller
      .setup({
        step: '.tributary-step',
        offset: 0.6,
        debug: false
      })
      .onStepEnter((response) => {
        const content = response.element.querySelector('.tributary-content');
        if (content) {
          content.classList.add('is-active');
        }
      });
    
    window.addEventListener('resize', scroller.resize);
  }
});
</script>